### 前缀树 Trie 字典树

**又称为单词查找树，是一种树形结构，是hash树的变种。用于统计 排序 保存打了的字符串。但不仅仅限制于字符串。优点：利用字符串的公共前缀来减少查询时间**



#### 性质

* 根节点不包含字符 根节点以外的每个节点包含一个字符
* 从根节点到某个节点 路径上的字符连起来 该节点对应的字符串
* 每个节点的所有子节点包含的字符都不同



基本操作有 查找 插入 删除。



#### 跟二叉树比较

**Trie数和二叉树不同，在trie中 每个结点上并非存储一个元素 字典树把要查找的关键看作一个字符序列。根据结构关键词字符的先后顺序构造用于检索的树结构。**

下面是**javascript版本的字典树**

```javascript

function TrieNode(key) {
  this.key = key;
  this.son = [];
}

function Trie() {
  this.root = new TrieNode(null);
}

Trie.prototype = {
  insertData(stringData) {
    this.insert(stringData, this.root);
  },
  insert(stringData, node) {
    if (stringData == '') {
      return;
    }
    var son = this.getSon(node);
    var haveData = null;
    for (var i in son) {
      if (son[i].key == stringData[0]) {
        haveData = son[i];
      }
    }
    if (haveData) {
      this.insert(stringData.substring(1), haveData); // 找到了对应的元素
    } else {
      if (son.length == 0) {
        // 当没有子元素 所以应该判断一下
        var node = new TrieNode(stringData[0]);
        son.push(node);
        this.insert(stringData.substring(1), node);
      } else {
        var validPosition = 0;
        for (var j in son) {
          if (son[j].key < stringData[0]) {
            validPosition++;
          }
        }
        var node = new TrieNode(stringData[0]);
        son.splice(validPosition, 0, node);
        this.insert(stringData.substring(1), node);
      }
    }
  },

  getSon(node) {
    return node.son;
  },
  printData(node, data) {
    if (node.son.length === 0) {
      return;
    }
    for (var i in node.son) {
      data.push(node.son[i].key);
      this.printData(node.son[i], data)
      data.pop();
    }
  },
  printData1() {
    for (var i in this.root.son) {
      this.printData(this.root.son[i], [this.root.son[i].key]);
    } 
  },

  isExit(node, queryData) {
    if (node.key == queryData[0]) {

    }
  }
};

var trie = new Trie();

trie.insertData('in');
trie.insertData('inn');
trie.insertData('ten');

trie.printData1();

console.log(trie);
```





















