### 时间复杂度

时间复杂度衡量一个算法的好坏。算法的 **时间复杂度**是一个函数表示该算法运行时间。

**衡量代码的好坏 包括两个非常重要的指标: **

* 运行时间
* 占用空间



#### 场景一

假设有一个面包 共五斤 两天吃一斤。那么需要10天。那么就是 2 X 5 = 10;

如果有N斤呢 那就是 N X 2 = 2N; 那么就可以用一个函数来表示相对时间。

 T(n) = 2n; 



#### 场景二 

如果有一条16寸的面包 每天吃掉面包剩余长度的一半 第一次吃掉8寸 第二次吃掉4寸 第三次吃掉2寸 剩余一寸要多少天。 这就是一个对数的概念 以2为底 16为对数 log16.

T(n) = logn



#### 场景三

如果一条面包10寸 吃掉第一寸要1天 第二寸2天 第三寸3天 以此类推 吃完就是

T(n) = 1 + 2 + 3 + ... + 10 =  (n + 1) * n \ 2;





### 怎么推导时间复杂度

1、如果运行时间是常数量级 用常数1表示

2、只保留时间函数中的最高阶级

3、如果最高阶级存在 就省去最高阶级前面的系数



时间复杂度用大写O表示 **T(n) = O(f(n))**

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2)  < O(n^3) < O(2^n) < O(n!)



常数时间O(1) 代表这个操作和数据量没关系，是一个固定操作 比如四则运算。











### 位运算

* 左移 <<  

  10 << 1 // 20 左移就是将二进制全部左移动。10 表示二进制 1010 左移一位就变成了10100 转换为十进制就是 20。 **基本可以把左移看成公式 a* (2 ^ b)  **

* 右移 >>

  10 >> 1 // -5  10右移一位就是 101。 **基本可以把右移看成以下公式 int v = a / (2 ^ b) **

  **右移可以很好的应用在二分查找取中间值  13 >> 1 == 6**


* 按位非 ~ 

  var num1 = ~num;  // -num - 1

  执行按位非的结果就是数值的反码。**基本上看做取相反数再减去1**

* 按位与 & 都为1才为1

  var result = 25 & 3; // 1

* 按位或 OR | 表示

  **有一位为1就是1 两位都为0 才为0 **

  var result = 25 | 3; // 27

* 按位异或 XOR **操作数上只有一位是1才返回1**



